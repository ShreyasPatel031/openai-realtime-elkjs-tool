import fs from 'fs';
import path from 'path';

interface IconInfo {
  name: string;
  category: string;
  provider: string;
  path: string;
}

interface IconLists {
  aws: { [category: string]: string[] };
  gcp: { [category: string]: string[] };
  azure: { [category: string]: string[] };
  all: string[];
}

/**
 * Recursively scans a directory for PNG files and returns their names without extension
 */
function scanDirectory(dir: string): string[] {
  const icons: string[] = [];
  
  if (!fs.existsSync(dir)) {
    return icons;
  }
  
  const files = fs.readdirSync(dir);
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      // Recursively scan subdirectories
      icons.push(...scanDirectory(filePath));
    } else if (file.endsWith('.png')) {
      // Add PNG file without extension
      icons.push(path.basename(file, '.png'));
    }
  }
  
  return icons;
}

/**
 * Scans the organized icon directories and generates icon lists
 */
function generateIconLists(): IconLists {
  const iconLists: IconLists = {
    aws: {},
    gcp: {},
    azure: {},
    all: []
  };
  
  const baseDir = path.join(process.cwd(), 'client/public/icons');
  const providers = ['aws', 'gcp', 'azure'];
  
  for (const provider of providers) {
    const providerDir = path.join(baseDir, provider);
    
    if (!fs.existsSync(providerDir)) {
      console.warn(`Provider directory not found: ${providerDir}`);
      continue;
    }
    
    const categories = fs.readdirSync(providerDir).filter(item => {
      const itemPath = path.join(providerDir, item);
      return fs.statSync(itemPath).isDirectory();
    });
    
    for (const category of categories) {
      const categoryDir = path.join(providerDir, category);
      const icons = scanDirectory(categoryDir);
      
      if (icons.length > 0) {
        iconLists[provider as keyof typeof iconLists][category] = icons.sort();
        iconLists.all.push(...icons);
      }
    }
  }
  
  // Remove duplicates and sort the combined list
  iconLists.all = Array.from(new Set(iconLists.all)).sort();
  
  return iconLists;
}

/**
 * Generates TypeScript file with icon lists for the application
 */
function generateIconListsFile(iconLists: IconLists): void {
  const outputDir = path.join(process.cwd(), 'client/generated');
  const outputFile = path.join(outputDir, 'iconLists.ts');
  
  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Create provider-prefixed icon lists for clear identification
  const awsIconsFlat = Object.values(iconLists.aws).flat().map(icon => `aws_${icon}`);
  const gcpIconsFlat = Object.values(iconLists.gcp).flat().map(icon => `gcp_${icon}`);
  const azureIconsFlat = Object.values(iconLists.azure).flat().map(icon => `azure_${icon}`);
  const allPrefixedIcons = [...awsIconsFlat, ...gcpIconsFlat, ...azureIconsFlat].sort();
  
  const tsContent = `// This file is auto-generated by scripts/generateIconList.ts
// Do not edit manually - changes will be overwritten

export interface IconLists {
  aws: { [category: string]: string[] };
  gcp: { [category: string]: string[] };
  azure: { [category: string]: string[] };
  all: string[];
}

export const iconLists: IconLists = ${JSON.stringify(iconLists, null, 2)};

// Provider-prefixed icons for reasoning agent (avoids confusion between providers)
export const availableIconsPrefixed = ${JSON.stringify(allPrefixedIcons, null, 2)};

// Original flat list of all available icons (for backward compatibility)
export const availableIcons = iconLists.all;

// Provider-specific icon lists
export const awsIcons = iconLists.aws;
export const gcpIcons = iconLists.gcp;
export const azureIcons = iconLists.azure;

// Helper function to get icons by provider and category
export function getIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): { [category: string]: string[] } {
  return iconLists[provider];
}

// Helper function to get all icons for a specific category across all providers
export function getIconsByCategory(category: string): string[] {
  const icons: string[] = [];
  
  for (const provider of ['aws', 'gcp', 'azure'] as const) {
    if (iconLists[provider][category]) {
      icons.push(...iconLists[provider][category]);
    }
  }
  
  return Array.from(new Set(icons)).sort();
}

// Helper function to search icons by name
export function searchIcons(query: string): string[] {
  return iconLists.all.filter(icon => 
    icon.toLowerCase().includes(query.toLowerCase())
  );
}

// Helper function to get provider-specific prefixed icons
export function getProviderPrefixedIcons(provider: 'aws' | 'gcp' | 'azure'): string[] {
  const providerIcons = Object.values(iconLists[provider]).flat();
  return providerIcons.map(icon => \`\${provider}_\${icon}\`).sort();
}

// Helper function to parse prefixed icon name back to provider and icon
export function parseIconName(prefixedIcon: string): { provider: string; icon: string } | null {
  const match = prefixedIcon.match(/^(aws|gcp|azure)_(.+)$/);
  return match ? { provider: match[1], icon: match[2] } : null;
}

// Statistics
export const iconStats = {
  total: iconLists.all.length,
  aws: Object.values(iconLists.aws).flat().length,
  gcp: Object.values(iconLists.gcp).flat().length,
  azure: Object.values(iconLists.azure).flat().length,
  categories: {
    aws: Object.keys(iconLists.aws).length,
    gcp: Object.keys(iconLists.gcp).length,
    azure: Object.keys(iconLists.azure).length,
  }
};
`;
  
  fs.writeFileSync(outputFile, tsContent);
  console.log(`‚úÖ Generated icon lists: ${outputFile}`);
  console.log(`üìä Total icons: ${iconLists.all.length}`);
  console.log(`   - AWS: ${Object.values(iconLists.aws).flat().length}`);
  console.log(`   - GCP: ${Object.values(iconLists.gcp).flat().length}`);
  console.log(`   - Azure: ${Object.values(iconLists.azure).flat().length}`);
  console.log(`üè∑Ô∏è  Provider-prefixed icons: ${allPrefixedIcons.length}`);
}

/**
 * Main function
 */
function main(): void {
  console.log('üîç Scanning organized icon directories...');
  
  const iconLists = generateIconLists();
  generateIconListsFile(iconLists);
  
  console.log('‚ú® Icon list generation complete!');
}

// Run the main function when script is executed
main();

export { generateIconLists, generateIconListsFile }; 